# -*- coding: utf-8 -*-
"""perceptron-cavasin_143501.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/ncavasin/fba4c9d087448e9eae7aafcf25edb8c7/perceptron-cavasin_143501.ipynb
"""

import numpy as np
import pandas as pd

# Hardcodeo los valores de las tres entradas, pues no van a variar
x1 = pd.Series((0, 0, 0, 0, 1, 1, 1, 1), name='x1')
x2 = pd.Series((0, 0, 1, 1, 0, 0, 1, 1), name='x2')
x3 = pd.Series((0, 1, 0, 1, 0, 1, 0, 1), name='x3')

# Defino contador para luego mostrar en matriz
iter = 0

# Los combino en una matriz
matriz = pd.concat([x1, x2, x3], axis=1)

# Defino la funcion de salida, en este caso la funcion logica AND
y = pd.Series((0, 0, 0, 0, 0, 0, 0, 1), name='y')

# La inserto a la tabla
matriz = pd.concat([matriz, y], axis=1)

# Muestro la tabla
matriz

def sep_function(z):
    """
    Esta funcion representa la separacion lineal de cada salida obtenida.
    Si z >= 0.5 ==> z = 1
    Si z <  0.5 ==> z = 0
    """

    if z >= 0.5:
        return 1
    else:
        return 0


def adjust(z, y, t, p, lr):
    
    # Calculo error
    error = y - z

    # Ajusto threhsold
    t = t + (-1 *(lr * error))

    # Ajusto pesos
    p['x1'] += (p['x1'] * lr * error)
    p['x2'] += (p['x2'] * lr * error)
    p['x3'] += (p['x3'] * lr * error)

    return t, p


def train(mat, p, t, lr, e):

    errores = True

    while errores and e < 100:
        errores = False

        # Creo lista para almacenar valores calculados
        z2 = []

        for i in range(0, matriz.shape[0]):

            # Calculo z
            z = ((mat['x1'][i] * p['x1']) + (mat['x2'][i] * p['x2']) + (mat['x3'][i] * p['x3'])) - t

            # Aplico la funcion de separacion
            z = sep_function(z)

            # Verifico si hubo error
            if z != mat['y'][i]:
                errores = True

                # Ajusto
                t, p = adjust(z, mat['y'][i], t, p, lr)
                
                # Incremento contador de iteraciones
                e += 1     
            
            # Agrego el valor calculado a la lista
            z2.append(z)
    if epochs == 100:
        exit(-1)
    else:
        return t, p, e, z2


import random 

# Defino los valores iniciales del threshold, learn rate y epochs
threshold = 0.5
learn_rate = 0.2
epochs = 0

# Inicializo pesos al azar
pesos = {}
pesos['x1'] = np.float(round(random.uniform(0, 1.5), 2))
pesos['x2'] = np.float(round(random.uniform(0, 1.5), 2))
pesos['x3'] = np.float(round(random.uniform(0, 1.5), 2))


print('PARAMETROS INICIALES:')
print(f'Epochs = {epochs}')
print(f'Threshold = {threshold:.2f}')
print(f"Vel aprendizaje = {learn_rate}")
for index, value in enumerate(pesos):
    print(f'Peso {index} = {pesos[value]:.4f}')


print('\n<=== INI PERIODO DE ENTRENAMIENTO ===>')
# Entreno
threshold, pesos, epochs, z = train(matriz, pesos, threshold, learn_rate, epochs)

# Formateo para mostrar
z = pd.Series(np.asarray(z), name=f'z{iter}')
matriz = pd.concat([matriz, z], axis= 1)

# Aumento el contador de veces ejecutadas del algoritmo
iter += 1
print('<=== FIN PERIODO DE ENTRENAMIENTO ===>')


print('\nPARAMETROS FINALES:')
print(f'Epochs = {epochs}')
print(f'Threshold = {threshold:.2f}')
print(f"Vel aprendizaje = {learn_rate}")
for index, value in enumerate(pesos):
    print(f'Peso {index} = {pesos[value]:.4f}')

print('\n\nMatriz original con los Z calculados:')
matriz

import plotly.graph_objects as go

xx = np.linspace(-1,1,10)
yy = np.linspace(-1,1,10)
X,Y = np.meshgrid(xx,yy)

Z = (pesos['x1'] * X + pesos['x2'] * Y + threshold) / pesos['x3']

fig = go.Figure(data=[go.Surface(x=X, y=Y,z=Z, colorscale=['cyan', 'cyan', 'cyan']),   
                      go.Scatter3d(x=matriz['x1'], y=matriz['x2'], z=matriz['x3'],
                                   mode='markers', marker=dict(size=4, color='green'))
                      ]
                )

fig.update_layout(width=800, height=800)
fig.show()
